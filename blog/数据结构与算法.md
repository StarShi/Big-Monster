# [数据结构 = 程序 + 算法](https://github.com/StarShi/Big-Monster/tree/master/source/data-structure)


## 一、逻辑结构与物理结构

- 物理结构：数据的逻辑结构正在计算机中的存储形式

- 逻辑结构：数据对象中，元素之间的相互关系（集合结构、线性结构、树型结构、图形结构）



## 二、算法

算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法特征：输入、输出、有穷性、确定性、可行性。

>好算法特征：
>1. 正确性
>2. 健壮性（容错性）
>3. 可读性
>4. 效率



## 三、算法的复杂度

时间频度:算法花费的时间与算法中语句执行的次数成正比例，可以一个算法中的语句执行次数称为时间频度，记作T(n)。

时间复杂度：是一个函数f(n)，它定性描述了该算法的运行时间。当n趋于无穷大时，若T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同量级函数，记作T(n) = O(f(n))，O(f(n))称为算法的渐进时间复杂度，简称时间复杂度。

大O记号：时间复杂度常用大O符号表述，不包括这个函数的低阶项和高阶首项系数

1. 常系数可以忽略
2. 低次项可以忽略
3. 高阶项系数可以忽略
4. 对数常底数可以忽略


级数与大O记号表示

1. 算数级数：与末项平方同阶 
2. 幂方级数：比幂次高出一阶
3. 几何级数：与末项同阶
4. 收敛级数：O(1)

常见的时间复杂度

1. 常数阶O(1)
2. 对数阶O(logn) 
3. 线性阶O(n)
4. 线性对数阶O(nlogn)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. k次方阶O(n^k)
8. 指数阶O(2^n)

> 时间复杂度: O(1) < O(logn)<  O(n)< O(nlogn) < O(n^2) < O(n^3) < O(n^k) < O(2^n)


## 四、数据结构

抽象数据类型（ADT）：是一个实现包括储存数据元素的存储结构以及实现基本操作的算法

数据结构：是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成


### 线性结构和非线性结构

#### 线性结构

1. 数据元素之间存在一对一的关系
2. 存储方式有两种，顺序存储结构和链式存储结构
3. 顺序存储结构是连续的，链式存储结构不一定连续
4. 常见的线性结构：数组、队列、链表和栈

#### 非线性的结构

1. 常见的非线性的结构：多维数组，广义表，树结构，图结构

### 数据结构——二维数组和稀疏数组

#### [二维数组（TwoDimensionArray）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/two-array/index.ts)

#### [稀疏数组（SparseArray）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sparse-array/index.ts)

当二维数组中存在大量的内容值未被使用时，可通过稀疏数组来缩减原始数组的规模。

应用：棋盘存盘

存储方式：

1. 第一行存储原始数据总行数，总列数，总的非0数据个数

2. 接下来每一行都存储非0数所在行，所在列，和具体值

```
	rows cols n                
	r1   c1   val1       
	r2   c2   val2       
	.    .     .
	.    .     .
	rn   cn   valn
```

例如：
```
	0 0 0 0            4 4 1
	0 0 5 0            1 2 5
	0 8 0 0            2 1 8
	0 0 0 0
```

> 将 4x4 的数组，转换成了2x3 的数组，缩减了数组规模


二维数组 -> 稀疏数组

>实现思路：
>1. 遍历原始数组，得到有效的数据个数count
>2. 根据count创建稀疏数组sparseArr[count + 1][3]
>3. 将原始数组的有效数据存入稀疏数组中

稀疏数组 -> 二维数组

>实现思路：
>1. 遍历原始数组，得到有效的数据个数count
>2. 根据count创建稀疏数组sparseArr[count + 1][3]
>3. 将原始数组的有效数据存入稀疏数组中

### 数据结构——队列（Queue）

结构特点：先进先出
操作：
1. 入队
2. 出队
3. 判断队满
4. 判断队空
5. 初始化时设置队列长度

#### [数组模拟队列（ArrayQueue）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-queue/index.ts)

> javascript中的数组比较灵活，因此无需使用环形队列对数组进行复用

#### 链表模拟队列

### 数据结构——链表（LinkedList）

#### [单链表（SingleLinkedList）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/single-linked-list/index.ts)


结构特点：以节点的方式存储，每个节点包含next域、data域，next指向下一个结点，data存储数据
操作：
1. 添加
2. 删除
3. 修改
4. 查找
5. 链表长度
6. 判断空
7. 获取某个节点的位置
8. 获取某个位置的前一个节点

思路：
1. 创建节点类
2. 创建空的头节点
3. 实现相关方法

缺点：
1. 只能从一个方向查找
2. 插入、删除都只能当前位置的前一个节点进行删除

相关算法题：
1. 获取倒数的第k个节点
2. 反转单链表
3. 逆序打印单链表
4. 单向环形链表解决josephu问题

> 约瑟夫问题：设编号1、2、3、...n的n个围坐一圈，约定编号为k的人开始报数，数到m位置的人出队列，它的下一个人又从1开始数，数到m位置的人出队列继续出队列，以此类推，直到所有人出队列为止，由此产生的出队编号序列是？

#### [双向链表（DoubleLinkedList）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/double-linked-list/index.ts)

结构特点：以节点的方式存储，每个节点包含pre域、next域、data域，pre指向上一个节点，next指向下一个结点，data存储数据

操作：
1. 添加
2. 删除
3. 修改
4. 查找
5. 链表长度
6. 判断空
7. 获取某个节点的位置
8. 获取某个位置的节点

思路：
1. 创建节点类
2. 创建空的头节点和尾节点
3. 实现相关方法

特点：
1. 可以双向查找
2. 插入和删除时，无需获取当前节点的前一个节点，可直接获取当前节点进行操作

### 数据结构——栈（Stack）

结构特点：先入后出，插入删除元素只能在同一端进行，栈顶变化，栈底固定

操作：
1. 入栈
2. 出栈

应用：
1. 子程序调用：在调用子程序前，会将下一个指令的地址存到栈中，直到子程序执行完毕，在将地址取出，以回到原来的程序中
2. 处理递归：和子程序类似，除了存储指令以外，也将参数，变量等数据存到堆栈中
3. 表达式的转换和求解
4. 二叉树的遍历
5. 图形的深度优先搜索

相关算法：
1. [使用栈求解中缀表达式](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/calculator.ts)

	思路：
   - 构建数栈和符号栈
   - 扫描字符串，遍历表达式
   - 如果扫描出数字，直接入栈
   - 如果扫描出符号，分两种情况，若是栈空直接入栈，若是符号栈有操作符，就比较当前符号和栈顶符号的优先级，当前符号<=栈顶符号,取出符号栈中的符号和数栈中的两个栈进行运算，得到的结果入数栈，再次比较直到符号入栈，如果当前符号优先顶符号优先级,直接将符号入符号栈
   - 当表达式扫描完毕，就从数栈和符号栈中取出相应的数和符号，计算结果入数栈
   - 最后在数栈中的最后一个数字就是表达式的结果

2. [使用栈求解后缀表达式](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/polandCalculator.ts)

	思路：
   - 构建栈和一个数组
   - 从左往右扫描，遇数压入栈遇见符号去取两个数进行运算，并将结果入栈
   - 重复扫描，直至表达式左右端
   - 在数栈中的最后一个数字就是表达式的结果

3. [中缀表达式转后缀表达式]()

	思路：
    - 初始化两个栈，符号栈s1和中间结果栈s2
    - 从左到右扫描中缀表达式
    - 遇操作数时，将其压入 s2
    - 遇运算符时，与s1栈顶元素比较优先级，若s1为空，或栈顶运算符为左括号,则为将此运算符入栈，否则，若是优先级高于栈顶运算符，也直接入栈。若是优先级小于等于栈顶运算符，将s1栈顶运算符弹出并压入s2中，然后对当前操作符再次进行判断
    - 遇见括号时，若是左括号，直接压入s1,若是右括号，则一次弹出s1栈顶运算符，并压入s2，直至遇见左括号为止，此时将这对括号丢弃
    - 重复上述扫描，直到表达式的最右边
    - 将s1中剩余的运算符依次弹出，压入s2
    - 将s2中的元素依次弹出，即结果的逆序，即为中缀表达式对应的后缀表达式

注意：因为s2没有出栈操作，所以可以用一个数组代替，顺序打印即为后缀表达式
   
#### [数组模拟栈（ArrayStack）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/index.ts)

1. 前缀表达式：也称波兰表达式，运算符位于操作数之前，如(3+4)x5-6的前缀表达式是-x+3456，从右往左扫描，依次入数栈和符号栈，然后出栈运算
2. 中缀表达式：常见的运算表达式，如(3+4)x5-6
3. 后缀表达式：也称逆波兰表达式，运算符位于操作数之后，如(3+4)x5-6的后缀表达式是34+5x6-,从左往右扫描，遇数压入栈，遇见符号去取两个数进行运算，并将结果入栈，重复扫描，直至表达式左右端


### 数据结构——哈希表（HashTable）

### 数据结构——树（Tree）

树是一种非线性存储的数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合；

#### 数据结构——二叉树（BinaryTree）

二叉树：每个节点最多有两个子孩子的树

前序遍历：按根节点、左孩子、右孩子的顺序进行遍历
1. 先输出当前节点（初始时是根节点）
2. 如果左节点不为空，则递归继续前序遍历
3. 如果右节点不为空，则递归继续前序遍历

中序遍历：按左孩子、根节点、右孩子的顺序进行遍历
1. 如果左节点不为空，则递归继续中序遍历
2. 先输出当前节点（初始时是根节点）
3. 如果右节点不为空，则递归继续中序遍历

后序遍历：按左孩子、根节点、右孩子的顺序进行遍历
1. 如果左节点不为空，则递归继续后序遍历
2. 如果右节点不为空，则递归继续后序遍历
3. 输出当前节点（初始时是根节点）

#### 数据结构——顺序二叉树（ArrayBinaryTree）

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，这种树称为顺序二叉树。

特点：
1. 顺序二叉树一般只考虑完全二叉树
2. 二叉树中第n个元素的左子节点在数组中的下标为2n+1
3. 二叉树中第n个元素的右子节点在数组中的下标为2n+2
4. 二叉树中第n个元素的父子节点在数组中的下标为(n-1)/2
5. n：表示二叉树中的第n个元素，从0开始编号

实例：请以前序遍历的方式遍历该数组[1,2,3,4,5,6,7],输出结果为1，2，4，5，3，6，7

#### 数据结构——线索化二叉树（ThreadedBinaryTree）

n个节点的二叉链表中含有n+1个空指针域，利用二叉链表的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针，这种附加的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树，根据线索性质的不同可以分为前序线索二叉树、中序线索二叉树、后续线索二叉树

## 算法

### 算法——递归（Recursion）

递归：自己调用自己
调用机制：
- 当程序执行到一个方法时，会在栈中开辟一个独立的空间（栈）,每个栈空间中的原始变量相互独立，不会相互影响
- 递归调用时，方法内部的代码指令会依次入栈
- 当满足退出递归条件后，栈中代码会依次出栈执行，并将结果返回

例如：

```javascript
function sum (n){

	if(n===1){
		return 1
	}else{
		return n + sum(n-1);
	}

}
sum(3);// 3 + 2 + 1
```

分析：

- 入栈
  1. n=3,sum(3)入栈
  2. n=2,sum(2)入栈
  3. n=1,sum(1)入栈

- 出栈 
  1. sum(1),出栈执行，返回1，
  2. sum(2),出栈执行，返回2 + 1，
  3. sum(3),出栈执行，返回3 + 3，
  4. 栈空，方法调用结束

应用：

1. 解决数学问题：阶乘问题，迷宫问题，汉罗塔问题，八皇后问题
2. 排序算法中使用，快排，归并排序，二分查找，分治算法
3. 用栈解决的问题，可用递归实现

#### [递归——八皇后问题](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/recursion/eightQueue.ts)
在8x8的国际象棋的棋盘上摆放8个皇后，使其互相不能攻击，即任意两个皇后不能处于同一行，同一列，或同一斜线上，问有几种方法？

思路：
- 第一个皇后，放在第一行的第一列
- 第二个皇后。放在第二行的第二列，判断是否可以摆放，如不行，继续尝试第二列，第三列的位置，依次把所有列放完，找到一个合适的位置
- 如上放置第三个皇后，直到找到正确的位置
- 当得到一个正确解时，栈回退到上个一栈，开始回溯，如此便可将第一个皇后放置在第一列的解全部得到
- 继续将皇后放置在第二列，然后重复上述步骤，直到全部放完为止

### 算法——排序（SortAlgorithm）

排序：将一组数据依据指定的顺序进行排序的过程

排序的分类
1. 内容排序：将需要处理的所有数据都加载到内部存储器中进行排序
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储（如文件、磁盘等）进行排序

内部排序：

1. 插入排序：直接插入、希尔排序
2. 选择排序：简单选择排序、堆排序
3. 交换排序：冒泡排序、快速排序
4. 归并排序
5. 基数排序

#### [排序——冒泡排序（Bubble）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：从下标较小的元素开始，依次比较相邻的值，若发现逆序，则交换，如此循环冒泡，直至没有相邻元素需要交换为止,此时该序列就完成了排序。

 > 优化：一次冒泡的过程中，若没有产生交换(flag = false)，即认为序列已经有序，无需继续进行冒泡

#### [排序——选择排序（Select）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零时，序列完成排序。

#### [排序——直接插入排序（Select）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：默认序列的第一个值为一个有序序列，把剩余待排序的记录按值的大小逐个插入到该有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。

> - 交换法：待插入元素与有序序列从后往前进行相互比较，如果逆序则进行交换，直到完成有序序列的遍历为止，数据量大时，效率较低。
> - 后移法：设置变量临时缓存待插入元素的值，如果待插元素逆序，使得有序序列，从后往前与临时变量进行相互比较，如果逆序则使有序序列的元素向后移动一个位置，直到找到适合待插元素的位置为止，并将该位置的值重新修改为临时变量的值，完成插入操作。

> 因为后移法每次比较都只进行一次赋值运算，找到插入位置后也只进行一次插入操作，所以效率较高，而交换法，每次进行比较都需要进行至少两次赋值运算，所以效率较低。

#### [排序——希尔排序（Shell）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

希尔排序是对直接插入排序的一种改进；

思想：先取一个小于n的整数d1作为第一个增量，把文件的全部元素分组。所有距离为d1的倍数的元素放在同一个组中。先在各组内进行直接插入排序，让其尽可能接近最终的位置；然后，取第二个增量d2 < d1 重复上述的分组和排序，直至所取的增量 = 1 ( < … < d2 < d1)，即所有元素放在同一组中完成一次直接插入排序为止。

> 一般的初次取序列的一半为增量，以后每次减半，直到增量为1。

#### [排序——快速排序（Quick）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

快速排序是对冒泡排序的一种改进；

思想：分而治之，首先任意选取一个数据（通常选用数组中间的数）作为分界，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，完成一次快排分界值就找到了正确的位置，并且该元素之后不需要任何移动，然后在对分界值两边的序列分别选取分界值，重复进行（递归）上述操作，直到序列左、右边各数据排序完成，至此快排结束。

#### [排序——归并排序（Merge）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：与快排一样采用分而治之的策略，将问题分解成一些小问题，然后递归求解，归并排序是将一个序列折半拆分，直至形成只有单个元素的有序的子序列，再将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序，直至合并成完整的序列为止

#### [排序——基数排序（Merge）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

基数排序是桶排序的一种扩展；属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）顾名思义，它是透过键值的部份信息，将要排序的元素分配至某些“桶”中，藉以达到排序的作用

思想：将有待排序的数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成后，数列就变成了一个有序的序列了。

>最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。

> 最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。


### 算法——查找（SearchAlgorithm）

查找：
1. 线性查找
2. 二分查找
3. 插值查找
4. 斐波那契查找

#### [查找——线性查找(Line)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

思路：循环遍历列表，寻找匹配值的下标

#### [查找——二分查找(Binary)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

思路：找到数组中间的下标mid，如果寻找值>中间值，往右寻找中间值，继续递归查找，如果寻找值<中间值,往右寻找中间值递归查找，如果寻找值=中间值，则返回该中间值的下标。

结束递归：
1. 当找到时就结束递归
2. 寻找完整个数组，即left > right 时,若是仍然没有找到,则也需要结束递归、

#### [查找——插值查找(Insert)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

插值查找算法类似二分查找，只不过mid不在是(left + right )/2,而是mid = left +  (right - left) * (findVal - list[left])/ (list[right] - list[left])

> 当待查找的序列分布均匀时，插值查找算法的速度优于二分查找，但当分布不均匀时，插值查找的效率不一定优于二分查找

#### [查找——斐波那契查找(Fibonacci)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。

斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的,其mid不是由二分或插值得到的，而是位于黄金分割点的附近，mid = left + F(k-1) -1，F代表斐波那契数列；

> 斐波那契的性质是 F(k) = F(k-1) + F(k-2)，推导出 F(k) - 1 = F(k-1) -1 + F(k-2) -1 + 1，该式说明，只要顺序表的长度为 F(k) - 1,就可以将该顺序表分成 F(k-1) -1 和 F(k-2) -1 两段，从而中间的位置为 mid = left + F(k-1) - 1;
> 但顺序表的长度不一定刚好等于 F(k) - 1，所以需要将顺序表长度n增加至 F(k) - 1，这里的k值只要能使得 F(k) - 1 大于或等于 n 即可，不足的位置可使用顺序表的最后一位进行填充


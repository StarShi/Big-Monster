# [数据结构 = 程序 + 算法](https://github.com/StarShi/Big-Monster/tree/master/source/data-structure)

## 一、逻辑结构与物理结构

- 物理结构：数据的逻辑结构正在计算机中的存储形式。

- 逻辑结构：数据对象中，元素之间的相互关系（集合结构、线性结构、树型结构、图形结构）。

## 二、算法

算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法特征：输入、输出、有穷性、确定性、可行性。

> 好算法特征：
>
> 1.  正确性
> 2.  健壮性（容错性）
> 3.  可读性
> 4.  效率

## 三、算法的复杂度

时间频度:算法花费的时间与算法中语句执行的次数成正比例，可以一个算法中的语句执行次数称为时间频度，记作 T(n)。

时间复杂度：是一个函数 f(n)，它定性描述了该算法的运行时间。当 n 趋于无穷大时，若 T(n)/f(n)的极限值为不等于零的常数，则称 f(n)是 T(n)的同量级函数，记作 T(n) = O(f(n))，O(f(n))称为算法的渐进时间复杂度，简称时间复杂度。

大 O 记号：时间复杂度常用大 O 符号表述，不包括这个函数的低阶项和高阶首项系数

1. 常系数可以忽略
2. 低次项可以忽略
3. 高阶项系数可以忽略
4. 对数常底数可以忽略

级数与大 O 记号表示

1. 算数级数：与末项平方同阶
2. 幂方级数：比幂次高出一阶
3. 几何级数：与末项同阶
4. 收敛级数：O(1)

常见的时间复杂度

1. 常数阶 O(1)
2. 对数阶 O(logn)
3. 线性阶 O(n)
4. 线性对数阶 O(nlogn)
5. 平方阶 O(n^2)
6. 立方阶 O(n^3)
7. k 次方阶 O(n^k)
8. 指数阶 O(2^n)

> 时间复杂度: O(1) < O(logn)< O(n)< O(nlogn) < O(n^2) < O(n^3) < O(n^k) < O(2^n)

## 四、数据结构

抽象数据类型（ADT）：是一个实现包括储存数据元素的存储结构以及实现基本操作的算法。

数据结构：是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。

### 线性结构和非线性结构

#### 线性结构

1. 数据元素之间存在一对一的关系；
2. 存储方式有两种，顺序存储结构和链式存储结构；
3. 顺序存储结构是连续的，链式存储结构不一定连续；
4. 常见的线性结构：数组、队列、链表和栈。

#### 非线性的结构

1. 常见的非线性的结构：多维数组，广义表，树结构，图结构。

### 数据结构——二维数组和稀疏数组

#### [二维数组（TwoDimensionArray）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/two-array/index.ts)

#### [稀疏数组（SparseArray）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sparse-array/index.ts)

当二维数组中存在大量的内容值未被使用时，可通过稀疏数组来缩减原始数组的规模。

应用：棋盘存盘。

存储方式：

1. 第一行存储原始数据总行数，总列数，总的非 0 数据个数。

2. 接下来每一行都存储非 0 数所在行，所在列，和具体值。

```
	rows cols n
	r1   c1   val1
	r2   c2   val2
	.    .     .
	.    .     .
	rn   cn   valn
```

例如：

```
	0 0 0 0            4 4 1
	0 0 5 0            1 2 5
	0 8 0 0            2 1 8
	0 0 0 0
```

> 将 4x4 的数组，转换成了 2x3 的数组，缩减了数组规模

二维数组 -> 稀疏数组

> 实现思路：
>
> 1.  遍历原始数组，得到有效的数据个数 count；
> 2.  根据 count 创建稀疏数组 sparseArr[count + 1][3]；
> 3.  将原始数组的有效数据存入稀疏数组中。

稀疏数组 -> 二维数组

> 实现思路：
>
> 1.  遍历原始数组，得到有效的数据个数 count；
> 2.  根据 count 创建稀疏数组 sparseArr[count + 1][3]；
> 3.  将原始数组的有效数据存入稀疏数组中。

### 数据结构——队列（Queue）

结构特点：先进先出
操作：

1. 入队
2. 出队
3. 判断队满
4. 判断队空
5. 初始化时设置队列长度

#### [数组模拟队列（ArrayQueue）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-queue/index.ts)

> javascript 中的数组比较灵活，因此无需使用环形队列对数组进行复用

#### 链表模拟队列

### 数据结构——链表（LinkedList）

#### [单链表（SingleLinkedList）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/single-linked-list/index.ts)

结构特点：以结点的方式存储，每个结点包含 next 域、data 域，next 指向下一个结点，data 存储数据
操作：

1. 添加
2. 删除
3. 修改
4. 查找
5. 链表长度
6. 判断空
7. 获取某个结点的位置
8. 获取某个位置的前一个结点

思路：

1. 创建结点类；
2. 创建空的头结点；
3. 实现相关方法。

缺点：

1. 只能从一个方向查找；
2. 插入、删除都只能当前位置的前一个结点进行删除。

相关算法题：

1. 获取倒数的第 k 个结点；
2. 反转单链表；
3. 逆序打印单链表；
4. 单向环形链表解决 josephu 问题。

> 约瑟夫问题：设编号 1、2、3、...n 的 n 个围坐一圈，约定编号为 k 的人开始报数，数到 m 位置的人出队列，它的下一个人又从 1 开始数，数到 m 位置的人出队列继续出队列，以此类推，直到所有人出队列为止，由此产生的出队编号序列是？

#### [双向链表（DoubleLinkedList）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/double-linked-list/index.ts)

结构特点：以结点的方式存储，每个结点包含 pre 域、next 域、data 域，pre 指向上一个结点，next 指向下一个结点，data 存储数据

操作：

1. 添加
2. 删除
3. 修改
4. 查找
5. 链表长度
6. 判断空
7. 获取某个结点的位置
8. 获取某个位置的结点

思路：

1. 创建结点类；
2. 创建空的头结点和尾结点；
3. 实现相关方法。

特点：

1. 可双向查找；
2. 插入和删除时，无需获取当前结点的前一个结点，可直接获取当前结点进行操作。

### 数据结构——栈（Stack）

结构特点：先入后出，插入删除元素只能在同一端进行，栈顶变化，栈底固定。

操作：

1. 入栈
2. 出栈

应用：

1. 子程序调用：在调用子程序前，会将下一个指令的地址存到栈中，直到子程序执行完毕，在将地址取出，以回到原来的程序中；
2. 处理递归：和子程序类似，除了存储指令以外，也将参数，变量等数据存到堆栈中；
3. 表达式的转换和求解；
4. 二叉树的遍历；
5. 图形的深度优先搜索。

相关算法：

1.  [使用栈求解中缀表达式](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/calculator.ts)

        	思路：

    - 构建数栈和符号栈；
    - 扫描字符串，遍历表达式；
    - 如果扫描出数字，直接入栈；
    - 如果扫描出符号，分两种情况，若是栈空直接入栈，若是符号栈有操作符，就比较当前符号和栈顶符号的优先级，当前符号<=栈顶符号,取出符号栈中的符号和数栈中的两个栈进行运算，得到的结果入数栈，再次比较直到符号入栈，如果当前符号优先顶符号优先级,直接将符号入符号栈；
    - 当表达式扫描完毕，就从数栈和符号栈中取出相应的数和符号，计算结果入数栈；
    - 最后在数栈中的最后一个数字就是表达式的结果。

2.  [使用栈求解后缀表达式](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/polandCalculator.ts)

        	思路：

    - 构建栈和一个数组；
    - 从左往右扫描，遇数压入栈遇见符号去取两个数进行运算，并将结果入栈；
    - 重复扫描，直至表达式左右端；
    - 在数栈中的最后一个数字就是表达式的结果。

3.  [中缀表达式转后缀表达式]()

    思路：

    - 初始化两个栈，符号栈 s1 和中间结果栈 s2；
    - 从左到右扫描中缀表达式；
    - 遇操作数时，将其压入 s2；
    - 遇运算符时，与 s1 栈顶元素比较优先级，若 s1 为空，或栈顶运算符为左括号,则为将此运算符入栈，否则，若是优先级高于栈顶运算符，也直接入栈。若是优先级小于等于栈顶运算符，将 s1 栈顶运算符弹出并压入 s2 中，然后对当前操作符再次进行判断；
    - 遇见括号时，若是左括号，直接压入 s1,若是右括号，则一次弹出 s1 栈顶运算符，并压入 s2，直至遇见左括号为止，此时将这对括号丢弃；
    - 重复上述扫描，直到表达式的最右边；
    - 将 s1 中剩余的运算符依次弹出，压入 s2；
    - 将 s2 中的元素依次弹出，即结果的逆序，即为中缀表达式对应的后缀表达式。

注意：因为 s2 没有出栈操作，所以可以用一个数组代替，顺序打印即为后缀表达式

#### [数组模拟栈（ArrayStack）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/index.ts)

1. 前缀表达式：也称波兰表达式，运算符位于操作数之前，如(3+4)x5-6 的前缀表达式是-x+3456，从右往左扫描，依次入数栈和符号栈，然后出栈运算；
2. 中缀表达式：常见的运算表达式，如(3+4)x5-6；
3. 后缀表达式：也称逆波兰表达式，运算符位于操作数之后，如(3+4)x5-6 的后缀表达式是 34+5x6-,从左往右扫描，遇数压入栈，遇见符号去取两个数进行运算，并将结果入栈，重复扫描，直至表达式左右端。

### 数据结构——哈希表（HashTable）

### 数据结构——树（Tree）

树是一种非线性存储的数据结构，它是由 n（n>=1）个有限结点组成一个具有层次关系的集合；

#### [数据结构——二叉树（BinaryTree）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/binary-tree/index.ts)

二叉树：每个结点最多有两个子孩子的树

前序遍历：按根结点、左孩子、右孩子的顺序进行遍历。

1. 先输出当前结点（初始时是根结点）；
2. 如果左结点不为空，则递归继续前序遍历；
3. 如果右结点不为空，则递归继续前序遍历。

中序遍历：按左孩子、根结点、右孩子的顺序进行遍历。

1. 如果左结点不为空，则递归继续中序遍历；
2. 先输出当前结点（初始时是根结点）；
3. 如果右结点不为空，则递归继续中序遍历。

后序遍历：按左孩子、根结点、右孩子的顺序进行遍历。

1. 如果左结点不为空，则递归继续后序遍历；
2. 如果右结点不为空，则递归继续后序遍历；
3. 输出当前结点（初始时是根结点）。

二叉树的删除：

1. 如果删除的结点是叶子结点，则删除该结点;
2. 如果删除的结点是非叶子结点，则删除该树。

#### [数据结构——顺序二叉树（ArrayBinaryTree）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-binary-tree/index.ts)

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，这种树称为顺序二叉树。

特点：

1. 顺序二叉树一般只考虑完全二叉树；
2. 二叉树中第 n 个元素的左子结点在数组中的下标为 2n+1；
3. 二叉树中第 n 个元素的右子结点在数组中的下标为 2n+2；
4. 二叉树中第 n 个元素的父子结点在数组中的下标为(n-1)/2；
5. n：表示二叉树中的第 n 个元素，从 0 开始编号。

实例：请以前序遍历的方式遍历该数组[1,2,3,4,5,6,7],输出结果为 1，2，4，5，3，6，7

#### [数据结构——线索化二叉树（ThreadedBinaryTree）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/threaded-binary-tree/index.ts)

n 个结点的二叉链表中含有 n+1 个空指针域，利用二叉链表的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针，这种附加的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树，根据线索性质的不同可以分为前序线索二叉树、中序线索二叉树、后续线索二叉树。

当线索化二叉树后，Node 结点的属性 left 和 right,有如下情况：

1. left 指向的是左子树，也有可能指向的是前驱结点；
2. right 指向的是右子树，也有可能指向的是后继结点。

#### [数据结构——赫夫曼树（HuffmanTree）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/huffman-tree/index.ts)

给定 n 个权值的做为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称哈夫曼树。

路径和路径长度：在一棵树中，从一个结点可以达到的孩子或孙子结点之间的通路，称为路径，通路中分支的数目称为路径长度，若规定根结点的层数为 1，则根结点到第 n 层结点的路径长度为 n-1。

结点的权以及带权路径长度：若将树种结点赋给一个有种某种含义的数值，则该数值称为该结点的权，而根结点到该结点之间的路径长度与该结点的权的乘积，即是结点的带权路径长度。

树的带权路径长度：所有叶子结点的带权路径长度之和，记作 WPL，WPL 最小的二叉树就是赫夫曼树。

特点：权值较大的结点离根结点较近。

应用：

1. 赫夫曼编码是一种可变字长的编码，是赫夫曼树在电讯通信中的经典应用之一；
2. 数据文件压缩，压缩率在 20% - 90%之间；

赫夫曼编码：

1. 输出字符串 i like like like you；
2. i:4 l:3 k:3 e:3 y:1 o:1 u:1 //每个字符出现的次数；
3. 利用上面字符出现的次数构建棵赫夫曼树，次数作为权值；
4. 根据赫夫曼树，给各个字符规定编码，向左的路径为 0，向右的路径为 1，生成编码表，形成的编码为前缀编码，即每个字符所对应的编码，都不会是任一字符编码的前缀；
5. 可根据编码输出对应的字符，为二进制码;
6. 编码后的字符比原字符长，可将其看成二进制码，每取 8 位为一个数，进行数据压缩；
7. 将压缩后的数进行数据解码，还原成二进制码；
8. 遍历二进制码，根据编码表，逆向取出原码，即可输出原字符。

> 注意：
>
> - 赫夫曼编码是无损压缩的，如果赫夫曼树中的排序算法是不稳定的，有可能产生的赫夫曼编码是不一致的，但不管编码是否一致，只要 WPL 一样，压缩的编码长度都不会变；
> - 可利用赫夫曼编码读取文件流，进行压缩和解压操作，如果处理的文件本身就是被压缩过的，那么赫夫曼编码压缩的效果不是很好。

#### [数据结构——二叉排序树（BinarySortTree）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/binary-sort-tree/index.ts)

对于二叉排序树的任何一个非叶子结点，要求左子结点比当前结点的值小，右子结点的值比当前结点的大，如果有相同的值，可以将该结点放在左子结点或右子结点。

二叉树的删除：

1. 删除叶子结点，需找到要删除的结点以及父结点，直接删除即可
2. 删除的结点只有一棵子树，第一种相同，需要找到要删除的子树，并找到其父结点，直接让其父结点指向当前删除结点的子树
3. 如果要删除的结点有两棵子树，需要找到要删除的子树，并找到其父结点，从当前要删除的子树的右子树中找到最小的结点（或者左子树找最大结点），用一个临时变量将其保存， 删除最小结点（最大结点），并将零时变量中的值赋给当前要删除的子树，至此结点删除成功。

缺点：给定一个数列[1,2,3,4,5,6]，创建一颗二叉排序树，其左子树全部为空，形式上更像一个单链表，对插入没有什么影响，但查询速度明显降低（因为需要依次比较），由于每次都需要比较左子树，所以其查询速度比单链表还要慢

#### [数据结构——平衡二叉树（BalancedBinaryTree）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/balanced-binary-tree/index.ts)

平衡二叉树，又名平衡二叉搜索树，是二叉排序树的一种优化树，它是一棵空树或者它的左右两棵子树的高度差绝对值不超过 1，并且左右子树都是一颗平衡二叉树。

常见的实现方法：红黑树，AVL，替罪羊树，Treap，伸展树

AVL 树旋转

单旋转——左旋转：

1. 创建一棵二叉排序树，例如[4,3,6,5,7,8]；
2. 以当前根结点的值创建一个新的结点；
3. 新结点的左子树设置成当前结点的左子树；
4. 新结点的右子树设置成当前结点的右子树的左子树；
5. 把当前结点的值换成其右子结点的值；
6. 把当前结点的右子树设置成右子树的右子树；
7. 把当前结点的左子树指向新结点；

> 左旋转的目的是降低右子树的高度，创建二叉排序树时，如果插入结点后，该树的右子树与左子树的高度差大于 1，则进行左旋，达到平衡

单旋转——右旋转：

1. 创建一棵二叉排序树，例如[10,12,8,9,7,6]；
2. 以当前根结点的值创建一个新的结点；
3. 新结点的右子树设置成当前结点的右子树；
4. 新结点的左子树设置成当前结点的左子树的右子树；
5. 把当前结点的值换成其左子结点的值；
6. 把当前结点的左子树设置成左子树的左子树；
7. 把当前结点的右子树指向新结点；

> 右旋转的目的是降低左子树的高度，创建二叉排序树时，如果插入结点后，该树的左子树与右子树的高度差大于 1，则进行右旋，达到平衡

注意：单旋转能处理的二叉树种类有限，如果右旋转时存在它的左子树的右子树的高度大于它的左子树的左子树高度，那仅仅使用单右旋得到的树，依然不是平衡二叉树；同理，如果左旋转时存在它的右子树的左子树的高度大于它的右子树的右子树高度，那使用使用单左旋得到的树依然不是平衡二叉树

双旋转：

1. 当前进行右旋转时，如果它的左子树的右子树的高度大于它的右子树的右子树高度
2. 则先对当前结点的左子结点进行左旋转
3. 然后再对当前结点进行右旋转操作即可

4. 当前进行左旋转时，如果它的右子树的左子树的高度大于它的左子树的左子树高度
5. 则先对当前结点的右子结点进行右旋转
6. 然后再对当前结点进行旋转操作即可

#### 数据结构——B 树、B+树、B\*树

B 树就是这么一种 m 叉的多路平衡树，有以下性质：

1. 每个结点最多有 m 个子结点
2. 除了根结点和叶子结点之外，其他的每个结点最少有 m/2（向上取整）个孩子结点
3. 根结点至少有两个孩子结点，（除了第一次插入的时候，此时只有一个结点，根结点同时是叶子结点）
4. 所有的叶子结点都在同一层
5. 有 k 个子结点的父结点包含 k-1 个关键码

除了上述性质以外，还满足以下几个特点：

1. 树高平衡，所有的叶结点都在同一层
2. 关键码没有重复，父结点中的关键码是其子结点的分解
3. B 树把值接近的相关记录放在同一个磁盘页中，从而利用了访问的局部性原理。
4. B 树保证树种至少有一部分比例的结点是满的。

B+树、B\*树是 B 树的一种延伸，类 B 树系的结构主要是面向磁盘文件系统数据结构，B 树的不足显而易见，在 B 树里面所有的结点都存储数据，这样导致在做范围查询的时候，性能比较低，所以才出现了 B+树等延伸结构。

B+树里面每个结点存储的关键码个数相比 B 树存的更多，而且 B+树非叶子结点不存储数据，只存储索引，所有关键字都出现在叶子结点的链表中，且链表中的关键字恰好是有序的，索引 B+树可以很好的支持范围查询。

B\*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针；

#### [数据结构——图（Graph）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/graph/index.ts)

图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。

类型：

1. 无向图（边无方向）
2. 有向图（边有方向）
3. 带权图（边有值）

图的表示方式：二维数组（邻接矩阵）、链表（邻接链表）

二维数组的实现方式：邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，邻接矩阵的值表示图中的顶点的连接关系，除此之外，还需要一个多余的集合来保存结点本身，邻接矩阵可使用该结点在集合的下标，例如用[row][col]的值来表示[row]顶点和[col]顶点的链接。

> 注意：邻接矩阵需要为每个顶点分配 n 个边的空间，其实有很多边都是不存在的，会造成一定的空间浪费

链表的实现方式：由数组 + 链表组成，只关心存在的边，不关心不存在的边。数组保存集合，链表保存边。

图的遍历：

1. 深度优先算法：从初始结点出发，初始结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，深度优先遍历是一个递归的过程。
2. 广度优先算法：类似分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按照这个顺序访问这些结点的邻接结点。

深度优先步骤：

1. 访问初始结点 v，并标记结点 v 为已访问；
2. 查找结点 v 的第一个邻接结点 w；
3. 若 w 存在，则继续执行步骤 4，若 w 不存在，则返回第一步，将 v 的下一个结点继续；
4. 若 w 未被访问，则对 w 进行深度优先遍历；
5. 若查找结点 v 的邻接结点的下一个邻接结点，转到步骤 3。

广度优先步骤：

1. 访问初始结点 v，并标记结点 v 为已访问；
2. 把 v 入队列；
3. 当队列非空时，继续执行，否则对结点 v 的访问结束；
4. 出队列，取得队头结点 u;
5. 查找结点 u 的第一个邻接结点 w;
6. 若结点 u 的邻接结点 w 不存在，则转到步骤 3，否则循环执行以下三个步骤
7. 若结点 w 尚未被访问，则访问结点 w 并标记为已访问；
8. 结点 w 入队列；
9. 查找结点 u 的继邻接结点 w 的后一个邻接结点，转到步骤六。

## 算法

### 算法——递归（Recursion）

递归：自己调用自己
调用机制：

- 当程序执行到一个方法时，会在栈中开辟一个独立的空间（栈）,每个栈空间中的原始变量相互独立，不会相互影响
- 递归调用时，方法内部的代码指令会依次入栈
- 当满足退出递归条件后，栈中代码会依次出栈执行，并将结果返回

例如：

```javascript
function sum(n) {
  if (n === 1) {
    return 1;
  } else {
    return n + sum(n - 1);
  }
}
sum(3); // 3 + 2 + 1
```

分析：

- 入栈

  1. n=3,sum(3)入栈
  2. n=2,sum(2)入栈
  3. n=1,sum(1)入栈

- 出栈
  1. sum(1),出栈执行，返回 1，
  2. sum(2),出栈执行，返回 2 + 1，
  3. sum(3),出栈执行，返回 3 + 3，
  4. 栈空，方法调用结束

应用：

1. 解决数学问题：阶乘问题，迷宫问题，汉罗塔问题，八皇后问题；
2. 排序算法中使用，快排，归并排序，二分查找，分治算法；
3. 用栈解决的问题，可用递归实现。

#### [递归——八皇后问题](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/recursion/eightQueue.ts)

在 8x8 的国际象棋的棋盘上摆放 8 个皇后，使其互相不能攻击，即任意两个皇后不能处于同一行，同一列，或同一斜线上，问有几种方法？

思路：

- 第一个皇后，放在第一行的第一列；
- 第二个皇后。放在第二行的第二列，判断是否可以摆放，如不行，继续尝试第二列，第三列的位置，依次把所有列放完，找到一个合适的位置；
- 如上放置第三个皇后，直到找到正确的位置；
- 当得到一个正确解时，栈回退到上个一栈，开始回溯，如此便可将第一个皇后放置在第一列的解全部得到；
- 继续将皇后放置在第二列，然后重复上述步骤，直到全部放完为止。

### 算法——排序（SortAlgorithm）

排序：将一组数据依据指定的顺序进行排序的过程。

排序的分类

1. 内容排序：将需要处理的所有数据都加载到内部存储器中进行排序；
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储（如文件、磁盘等）进行排序。

内部排序：

1. 插入排序：直接插入、希尔排序
2. 选择排序：简单选择排序、堆排序
3. 交换排序：冒泡排序、快速排序
4. 归并排序
5. 基数排序

#### [排序——冒泡排序（Bubble）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：从下标较小的元素开始，依次比较相邻的值，若发现逆序，则交换，如此循环冒泡，直至没有相邻元素需要交换为止,此时该序列就完成了排序。

> 优化：一次冒泡的过程中，若没有产生交换(flag = false)，即认为序列已经有序，无需继续进行冒泡

稳定性：冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

#### [排序——选择排序（Select）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零时，序列完成排序。

稳定性：选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第 n - 1 个元素，第 n 个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列 5 8 5 2 9，我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

#### [排序——直接插入排序（Select）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：默认序列的第一个值为一个有序序列，把剩余待排序的记录按值的大小逐个插入到该有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。

> - 交换法：待插入元素与有序序列从后往前进行相互比较，如果逆序则进行交换，直到完成有序序列的遍历为止，数据量大时，效率较低。
> - 后移法：设置变量临时缓存待插入元素的值，如果待插元素逆序，使得有序序列，从后往前与临时变量进行相互比较，如果逆序则使有序序列的元素向后移动一个位置，直到找到适合待插元素的位置为止，并将该位置的值重新修改为临时变量的值，完成插入操作。

> 因为后移法每次比较都只进行一次赋值运算，找到插入位置后也只进行一次插入操作，所以效率较高，而交换法，每次进行比较都需要进行至少两次赋值运算，所以效率较低。

稳定性：插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有 1 个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。

#### [排序——希尔排序（Shell）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

希尔排序是对直接插入排序的一种改进；

思想：先取一个小于 n 的整数 d1 作为第一个增量，把文件的全部元素分组。所有距离为 d1 的倍数的元素放在同一个组中。先在各组内进行直接插入排序，让其尽可能接近最终的位置；然后，取第二个增量 d2 < d1 重复上述的分组和排序，直至所取的增量 = 1 ( < … < d2 < d1)，即所有元素放在同一组中完成一次直接插入排序为止。

> 一般的初次取序列的一半为增量，以后每次减半，直到增量为 1。

稳定性：希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以 shell 排序是不稳定的。

#### [排序——快速排序（Quick）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

快速排序是对冒泡排序的一种改进；

思想：分而治之，首先任意选取一个数据（通常选用数组中间的数）作为分界，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，完成一次快排分界值就找到了正确的位置，并且该元素之后不需要任何移动，然后在对分界值两边的序列分别选取分界值，重复进行（递归）上述操作，直到序列左、右边各数据排序完成，至此快排结束。

稳定性：快速排序有两个方向，左边的 i 下标一直往右走，当 a[i] <= a[center_index]，其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。而右边的 j 下标一直往左走，当 a[j] > a[center_index]。如果 i 和 j 都走不动了，i <= j，交换 a[i]和 a[j],重复上面的过程，直到 i > j。 交换 a[j]和 a[center_index]，完成一趟快速排序。在中枢元素和 a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素 5 和 3（第 5 个元素，下标从 1 开始计）交换就会把元素 3 的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和 a[j] 交换的时刻。

#### [排序——归并排序（Merge）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：与快排一样采用分而治之的策略，将问题分解成一些小问题，然后递归求解，归并排序是将一个序列折半拆分，直至形成只有单个元素的有序的子序列，再将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序，直至合并成完整的序列为止。

稳定性：归并排序是把序列递归地分成短序列，递归出口是短序列只有 1 个元素（认为直接有序）或者 2 个序列（1 次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在 1 个或 2 个元素时，1 个元素不会交换，2 个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

#### [排序——基数排序（Merge）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

基数排序是桶排序的一种扩展；属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）顾名思义，它是透过键值的部份信息，将要排序的元素分配至某些“桶”中，藉以达到排序的作用

思想：将有待排序的数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成后，数列就变成了一个有序的序列了。

> 最高位优先(Most Significant Digit first)法，简称 MSD 法：先按 k1 排序分组，同一组中记录，关键码 k1 相等，再对各组按 k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 kd 对各子组排序后。再将各组连接起来，便得到一个有序序列。

> 最低位优先(Least Significant Digit first)法，简称 LSD 法：先从 kd 开始排序，再对 kd-1 进行排序，依次重复，直到对 k1 排序后便得到一个有序序列。

稳定性：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

#### [排序——堆排序（Merge）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

堆排序是一种选择排序，堆是具有以下性质的完全二叉树：

1. 大顶堆：每个结点的值都大于或等于其左右孩子结点的值，对左右孩子的的值的大小关系并没有要求，arr[i] >= arr[2*i+1] && arr[i] >= arr[2*i+2]；
2. 小顶堆：每个结点的值都小于或等于其左右孩子结点的值，对左右孩子的的值的大小关系并没有要求，arr[i] <= arr[2*i+1] && arr[i] <= arr[2*i+2]。

如果使用堆排序，升序一般大顶堆，降序一般采用小顶堆。

思想：将待排序序列构造成一个大顶堆（用数组的形式存储树，用树的遍历方式遍历数组），此时整个序列的最大值就是堆顶的根结点，将其与末尾的元素进行交换，此时数组末尾就为最大值，然后将剩余的 n-1 个元素重新构造成一个堆，这样就会得到 n 个元素的次小值，如此反复执行，便能得到一个有序的序列了，

例如:

1. 存在一棵树 arr[4,6,8,5,9]。
2. 此时我们此从最后一个非叶子结点开始（arr.length/2 - 1 = 1），从左至右，从上至下调整。
3. 比较非叶子结点和其左右孩子的大小，将其中最大的结点与非叶子结点交换。
4. 继续比较倒数第二个非叶子结点，重复步骤 2、3 的操作，直至将无序序列构造成一个大顶堆。
5. 将堆顶元素与末尾元素交换，此时数组末尾就为最大值，重复上述操作，将剩余的 4 个元素重新构造成堆
6. 如此反复，就可得到一个有序序列。

稳定性：在一个长为 n 的序列，堆排序的过程是从第 n / 2 开始和其子结点共 3 个值选择最大（大顶堆）或者最小（小顶堆），这 3 个元素之间的选择当然不会破坏稳定性。但当为 n / 2 - 1， n / 2 - 2， ... 1 这些个父结点选择元素时，就会破坏稳定性。有可能第 n / 2 个父结点交换把后面一个元素交换过去了，而第 n / 2 - 1 个父结点把后面一个相同的元素没 有交换，那么这 2 个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

### 算法——查找（SearchAlgorithm）

查找：

1. 线性查找
2. 二分查找
3. 插值查找
4. 斐波那契查找

#### [查找——线性查找(Line)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

思路：循环遍历列表，寻找匹配值的下标

#### [查找——二分查找(Binary)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

思路：找到数组中间的下标 mid，如果寻找值>中间值，往右寻找中间值，继续递归查找，如果寻找值<中间值,往右寻找中间值递归查找，如果寻找值=中间值，则返回该中间值的下标。

结束递归：

1. 当找到时就结束递归；
2. 寻找完整个数组，即 left > right 时,若是仍然没有找到,则也需要结束递归。

二分查找非递归实现

#### [查找——插值查找(Insert)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

插值查找算法类似二分查找，只不过 mid 不在是(left + right )/2,而是 mid = left + (right - left) \* (findVal - list[left])/ (list[right] - list[left])。

> 当待查找的序列分布均匀时，插值查找算法的速度优于二分查找，但当分布不均匀时，插值查找的效率不一定优于二分查找

#### [查找——斐波那契查找(Fibonacci)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/search-algorithm/index.ts)

斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。

斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的,其 mid 不是由二分或插值得到的，而是位于黄金分割点的附近，mid = left + F(k-1) -1，F 代表斐波那契数列；

> 斐波那契的性质是 F(k) = F(k-1) + F(k-2)，推导出 F(k) - 1 = F(k-1) -1 + F(k-2) -1 + 1，该式说明，只要顺序表的长度为 F(k) - 1,就可以将该顺序表分成 F(k-1) -1 和 F(k-2) -1 两段，从而中间的位置为 mid = left + F(k-1) - 1;
> 但顺序表的长度不一定刚好等于 F(k) - 1，所以需要将顺序表长度 n 增加至 F(k) - 1，这里的 k 值只要能使得 F(k) - 1 大于或等于 n 即可，不足的位置可使用顺序表的最后一位进行填充

### 算法——[分治算法(DivideAndConquer)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/divide-and-conquer/index.ts)

分治算法：将复杂的问题分解成两个或更多相同或相似的子问题，再将子问题分解成更小的子问题，直到最后子问题可以进行简单求解，原问题的解即是所有子问题解的合并

常见应用：

1. 二分查找
2. 快速排序
3. 归并排序
4. 汉诺塔
5. 线性时间选择
6. 循环赛日程表
7. 大整数乘法
8. 棋盘覆盖
9. 最接近点对问题

### 算法——[动态规划算法(DynamicProgramming)](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/dynamic-programming/index.ts)

动态规划算法：与分治算法类似，基本方式也是将待求解的问题分解成若干子问题的解，先求解子问题，然后从这些子问题的解得到原问题的解，与分治算法不同的是，适合于动态规划求解的问题，经分解后得到的子问题往往不是互相独立的，即下一个阶段的求解是建立在上一个子阶段的解的基础上，进行求解的

常见应用：

1. 背包问题：主要是指给定一个指定容量的背包，若干具有一定价值和重量的物品，如何使得选择放入背包的物品的价值最大。0-1 背包，指每种物品最多放入一件；完全背包，指每种物品都有无限件可用；v[i]、w[i]分别为第 i 个物品的价值和重量,v[i][j] 表示背包在前 i 个物品中能够装入容量为 j 的背包中的最大价值

```
 v[i][0] = v[0][j] = 0 // 表示填入表的第一行、第一列是 0
 w[i]>j 时，v[i][j] = v[i-1][j] // 当准备加入新增的物品时，如果它的容量大于当前背包的容量时，则直接使用上一个单元格的装入策略
 j>=w[i] 时，v[i][j] =max(v[i-1][j],v[i-1][j-w[i]]+v[i]) // 当准备加入的新增的物品的容量小于背包的容量时，装入的策略应该是在（上一个单元格装入的最大值，剩余空间的装入i-1个商品的最大值加上当前商品价值）中取最大值
```

### 算法——[KMP](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/dynamic-programming/index.ts)

KMP 算法，由三个人的名字命名，主要用于字符串匹配，判断一个字符串是否存在子串，如果存在，返回第一次出现的位置，否则返回-1

1. 暴力匹配：直接遍历比较原串和子串
2. KMP 匹配

KMP 匹配步骤

1. 主串的第一个字符和子串的第一个字符进行比较，如果不符合下标后移一位；
2. 重复第一步，直到有字符匹配为止；
3. 继续匹配下一个字符，如果主串与子串的字符不匹配；利用对子串计算的部分匹配表，得出主串下标的移动位置 = 已匹配的字符串数 - 对应的部分匹配值，或者主串不回溯，移动子串的位置

> 注意：如果主串与子串的字符不匹配，暴力匹配直接使主串子串的下标重置，重新开始匹配，而 KMP 算法是，利用之前已经匹配过的信息，避开已经匹配过的位置，直接往后移，提高效率

部分匹配表的计算方式：字符的前缀集合和后缀集合的最长共有元素的长度，已字符串“ABCDAB”为例

- A 的前缀和后缀都为空集，共有元素长度为 0
- AB 的前缀[A],后缀[B]，共有元素长度为 0
- ABC 的前缀[A,AB],后缀[C,BC]，共有元素长度为 0
- ABCD 的前缀[A,AB,ABC],后缀[D,CD,BCD]，共有元素长度为 0
- ABCDA 的前缀[A,AB,ABC,ABCD],后缀[A,DA,CDA,BCDA]，共有元素为 A，长度为 1
- ABCDAB 的前缀[A,AB,ABC,ABCD,ABCDA],后缀[B,AB,DAB,CDAB,BCDAB]，共有元素为 AB，长度为 2

其匹配表：
|字符|A|B|C|D|A|B|
|-|-|-|-|-|-|-|
|长度|0|0|0|0|1|2|

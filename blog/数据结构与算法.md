# [数据结构 = 程序 + 算法](https://github.com/StarShi/Big-Monster/tree/master/source/data-structure)


## 一、逻辑结构与物理结构

- 物理结构：数据的逻辑结构正在计算机中的存储形式

- 逻辑结构：数据对象中，元素之间的相互关系（集合结构、线性结构、树型结构、图形结构）



## 二、算法

算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法特征：输入、输出、有穷性、确定性、可行性。

>好算法特征：
>1. 正确性
>2. 健壮性（容错性）
>3. 可读性
>4. 效率



## 三、算法的复杂度

时间频度:算法花费的时间与算法中语句执行的次数成正比例，可以一个算法中的语句执行次数称为时间频度，记作T(n)。

时间复杂度：是一个函数f(n)，它定性描述了该算法的运行时间。当n趋于无穷大时，若T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同量级函数，记作T(n) = O(f(n))，O(f(n))称为算法的渐进时间复杂度，简称时间复杂度。

大O记号：时间复杂度常用大O符号表述，不包括这个函数的低阶项和高阶首项系数

1. 常系数可以忽略
2. 低次项可以忽略
3. 高阶项系数可以忽略
4. 对数常底数可以忽略


级数与大O记号表示

1. 算数级数：与末项平方同阶 
2. 幂方级数：比幂次高出一阶
3. 几何级数：与末项同阶
4. 收敛级数：O(1)

常见的时间复杂度

1. 常数阶O(1)
2. 对数阶O(logn) 
3. 线性阶O(n)
4. 线性对数阶O(nlogn)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. k次方阶O(n^k)
8. 指数阶O(2^n)

> 时间复杂度: O(1) < O(logn)<  O(n)< O(nlogn) < O(n^2) < O(n^3) < O(n^k) < O(2^n)


## 四、数据结构

抽象数据类型（ADT）：是一个实现包括储存数据元素的存储结构以及实现基本操作的算法

数据结构：是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成


### 线性结构和非线性结构

#### 线性结构

1. 数据元素之间存在一对一的关系
2. 存储方式有两种，顺序存储结构和链式存储结构
3. 顺序存储结构是连续的，链式存储结构不一定连续
4. 常见的线性结构：数组、队列、链表和栈

#### 非线性的结构

1. 常见的非线性的结构：多维数组，广义表，树结构，图结构

### 数据结构——二维数组和稀疏数组

#### [二维数组（TwoDimensionArray）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/two-array/index.ts)

#### [稀疏数组（SparseArray）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sparse-array/index.ts)

当二维数组中存在大量的内容值未被使用时，可通过稀疏数组来缩减原始数组的规模。

应用：棋盘存盘

存储方式：

1. 第一行存储原始数据总行数，总列数，总的非0数据个数

2. 接下来每一行都存储非0数所在行，所在列，和具体值

```
	rows cols n                
	r1   c1   val1       
	r2   c2   val2       
	.    .     .
	.    .     .
	rn   cn   valn
```

例如：
```
	0 0 0 0            4 4 1
	0 0 5 0            1 2 5
	0 8 0 0            2 1 8
	0 0 0 0
```

> 将 4x4 的数组，转换成了2x3 的数组，缩减了数组规模


二维数组 -> 稀疏数组

>实现思路：
>1. 遍历原始数组，得到有效的数据个数count
>2. 根据count创建稀疏数组sparseArr[count + 1][3]
>3. 将原始数组的有效数据存入稀疏数组中

稀疏数组 -> 二维数组

>实现思路：
>1. 遍历原始数组，得到有效的数据个数count
>2. 根据count创建稀疏数组sparseArr[count + 1][3]
>3. 将原始数组的有效数据存入稀疏数组中

### 数据结构——队列（Queue）

结构特点：先进先出
操作：
1. 入队
2. 出队
3. 判断队满
4. 判断队空
5. 初始化时设置队列长度

#### [数组模拟队列（ArrayQueue）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-queue/index.ts)

> javascript中的数组比较灵活，因此无需使用环形队列对数组进行复用

#### 链表模拟队列

### 数据结构——链表（LinkedList）

#### [单链表（SingleLinkedList）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/single-linked-list/index.ts)


结构特点：以节点的方式存储，每个节点包含next域、data域，next指向下一个结点，data存储数据
操作：
1. 添加
2. 删除
3. 修改
4. 查找
5. 链表长度
6. 判断空
7. 获取某个节点的位置
8. 获取某个位置的前一个节点

思路：
1. 创建节点类
2. 创建空的头节点
3. 实现相关方法

缺点：
1. 只能从一个方向查找
2. 插入、删除都只能当前位置的前一个节点进行删除

相关算法题：
1. 获取倒数的第k个节点
2. 反转单链表
3. 逆序打印单链表
4. 单向环形链表解决josephu问题

> 约瑟夫问题：设编号1、2、3、...n的n个围坐一圈，约定编号为k的人开始报数，数到m位置的人出队列，它的下一个人又从1开始数，数到m位置的人出队列继续出队列，以此类推，直到所有人出队列为止，由此产生的出队编号序列是？

#### [双向链表（DoubleLinkedList）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/double-linked-list/index.ts)

结构特点：以节点的方式存储，每个节点包含pre域、next域、data域，pre指向上一个节点，next指向下一个结点，data存储数据

操作：
1. 添加
2. 删除
3. 修改
4. 查找
5. 链表长度
6. 判断空
7. 获取某个节点的位置
8. 获取某个位置的节点

思路：
1. 创建节点类
2. 创建空的头节点和尾节点
3. 实现相关方法

特点：
1. 可以双向查找
2. 插入和删除时，无需获取当前节点的前一个节点，可直接获取当前节点进行操作

### 数据结构——栈（Stack）

结构特点：先入后出，插入删除元素只能在同一端进行，栈顶变化，栈底固定

操作：
1. 入栈
2. 出栈

应用：
1. 子程序调用：在调用子程序前，会将下一个指令的地址存到栈中，直到子程序执行完毕，在将地址取出，以回到原来的程序中
2. 处理递归：和子程序类似，除了存储指令以外，也将参数，变量等数据存到堆栈中
3. 表达式的转换和求解
4. 二叉树的遍历
5. 图形的深度优先搜索

相关算法：
1. [使用栈求解中缀表达式](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/calculator.ts)
	> 思路：
	> - 构建数栈和符号栈
	> - 扫描字符串，遍历表达式
	> - 如果扫描出数字，直接入栈
	> - 如果扫描出符号，分两种情况，若是栈空直接入栈，若是符号栈有操作符，就比较当前符号和栈顶符号的优先级，当前符号<=栈顶符号,取出符号栈中的符号和数栈中的两个栈进行运算，得到的结果入数栈，再次比较直到符号入栈，如果当前符号优先级>栈顶符号优先级,直接将符号入符号栈
	> - 当表达式扫描完毕，就从数栈和符号栈中取出相应的数和符号，计算结果入数栈
	> - 最后在数栈中的最后一个数字就是表达式的结果

2. [使用栈求解后缀表达式](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/polandCalculator.ts)
	> 思路：
	> - 构建栈和一个数组
	> - 从左往右扫描，遇数压入栈遇见符号去取两个数进行运算，并将结果入栈
	> - 重复扫描，直至表达式左右端
	> - 在数栈中的最后一个数字就是表达式的结果

3. [中缀表达式转后缀表达式]()
	>思路：
	> - 初始化两个栈，符号栈s1和中间结果栈s2
	> - 从左到右扫描中缀表达式
	> - 遇操作数时，将其压入 s2
	> - 遇运算符时，与s1栈顶元素比较优先级，若s1为空，或栈顶运算符为左括号,则为将此运算符入栈，否则，若是优先级高于栈顶运算符，也直接入栈。若是优先级小于等于栈顶运算符，将s1栈顶运算符弹出并压入s2中，然后对当前操作符再次进行判断
	> - 遇见括号时，若是左括号，直接压入s1,若是右括号，则一次弹出s1栈顶运算符，并压入s2，直至遇见左括号为止，此时将这对括号丢弃
	> - 重复上述扫描，直到表达式的最右边
	> - 将s1中剩余的运算符依次弹出，压入s2
	> - 将s2中的元素依次弹出，即结果的逆序，即为中缀表达式对应的后缀表达式

注意：因为s2没有出栈操作，所以可以用一个数组代替，顺序打印即为后缀表达式
   
#### [数组模拟栈（ArrayStack）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/array-stack/index.ts)

1. 前缀表达式：也称波兰表达式，运算符位于操作数之前，如(3+4)x5-6的前缀表达式是-x+3456，从右往左扫描，依次入数栈和符号栈，然后出栈运算
2. 中缀表达式：常见的运算表达式，如(3+4)x5-6
3. 后缀表达式：也称逆波兰表达式，运算符位于操作数之后，如(3+4)x5-6的后缀表达式是34+5x6-,从左往右扫描，遇数压入栈，遇见符号去取两个数进行运算，并将结果入栈，重复扫描，直至表达式左右端


## 算法

### 算法——递归（Recursion）

递归：自己调用自己
> 调用机制：
> - 当程序执行到一个方法时，会在栈中开辟一个独立的空间（栈）,每个栈空间中的原始变量相互独立，不会相互影响
> - 递归调用时，方法内部的代码指令会依次入栈
> - 当满足退出递归条件后，栈中代码会依次出栈执行，并将结果返回

例如：

```javascript
function sum (n){

	if(n===1){
		return 1
	}else{
		return n + sum(n-1);
	}

}
sum(3);// 3 + 2 + 1
```

分析：

- 入栈
1. n=3,sum(3)入栈
2. n=2,sum(2)入栈
3. n=1,sum(1)入栈

- 出栈 
1. sum(1),出栈执行，返回1，
2. sum(2),出栈执行，返回2 + 1，
3. sum(3),出栈执行，返回3 + 3，
4. 栈空，方法调用结束

应用：

1. 解决数学问题：阶乘问题，迷宫问题，汉罗塔问题，八皇后问题
2. 排序算法中使用，快排，归并排序，二分查找，分治算法
3. 用栈解决的问题，可用递归实现

#### [递归——八皇后问题](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)
>
> 在8x8的国际象棋的棋盘上摆放8个皇后，使其互相不能攻击，即任意两个皇后不能处于同一行，同一列，或同一斜线上，问有几种算法
> 
> 思路：
> - 第一个皇后，放在第一行的第一列
> - 第二个皇后。放在第二行的第二列，判断是否可以摆放，如不行，继续尝试第二列，第三列的位置，依次把所有列放完，找到一个合适的位置
> - 如上放置第三个皇后，直到找到正确的位置
> - 当得到一个正确解时，栈回退到上个一栈，开始回溯，如此便可将第一个皇后放置在第一列的解全部得到
> - 继续将皇后放置在第二列，然后重复上述步骤，直到全部放完为止

### 算法——排序（SortAlgorithm）

排序：将一组数据依据指定的顺序进行排序的过程

排序的分类
1. 内容排序：将需要处理的所有数据都加载到内部存储器中进行排序
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储（如文件、磁盘等）进行排序

内部排序：

1. 插入排序：直接插入、希尔排序
2. 选择排序：简单选择排序、堆排序
3. 交换排序：冒泡排序、快速排序
4. 归并排序
5. 基数排序

#### [排序——冒泡排序（Bubble）](https://github.com/StarShi/Big-Monster/blob/master/source/data-structure/src/sort-algorithm/index.ts)

思想：从下标较小的元素开始，依次比较相邻的值，若发现逆序，则交换，如此循环冒泡，直至没有相邻元素需要交换为止,此时该序列就完成了排序。

 > 优化：一次冒泡的过程中，若没有产生交换(flag = false)，即认为序列已经有序，无需继续进行冒泡




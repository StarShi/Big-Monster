# [探索前端的自动化测试方案](https://github.com/StarShi/Big-Monster/tree/master/source/auto-test)

对自动化测试来说，相对于发现未知的问题，其更大的作用在于避免可能的问题。

## 前置知识

### 测试分类

单元测试：指对程序中最小可测试单元进行的测试，例如测试一个函数、一个模块、一个组件。

集成测试：将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行的测试。

端到端测试：打开应用程序模拟输入，检查功能以及界面是否正确。

### 黑盒、白盒、灰盒测试

黑盒测试：也称功能测试，测试中把被测的软件当成一个黑盒子，不关心盒子的内部结构是什么，只关心软件的输入数据与输出数据。

白盒测试：又称结构测试或基于代码的测试。指打开盒子，去研究里面的源代码和程序结果。

灰盒测试：介于白盒测试与黑盒测试之间，多用于集成测试阶段。

### TDD & BDD

TDD(Test-Driven Development)：测试驱动开发，指在开发功能代码之前，先编写单元测试用例代码。

BDD(Behavior-Driven Development)：行为驱动开发，按照用户的行为来开发，再根据用户的行为编写测试用例。

## 前端测试方向

虽然单元测试已经有完善的工具体系，但对于需求多变持续的迭代开发方式来说，单测维护成本较高，而且也没法满足前端所有的测试需求，所以前端进行单测的投入产出比太大。

web类的应用可根据项目的测试需求，在集成测试和端到端测试进行选择，至于测试方向可尝试以下几个方向：

1. 界面回归测试

2. 功能测试

3. 性能测试
 
### 界面回归测试

测试页面显示是否正常，常见的做法有像素对比和dom结构对比，如果差异达到一定阈值则页面可能不正常。

### 功能测试

模拟用户操作，通过模拟正常的操作流程来判断页面展现是否符合预期

### 性能测试

性能测试：模拟网络环境，对加载时间、页面请求数、资源大小、是否开启缓存和Gzip、选择器性能、dom结构等等诸多指标进行监控，如果监控的指标达到了一定阈值则页面可能不正常


## 拟定测试方案

非框架类的前端项目实在是不太适合通过单测来保证程序的功能，尽管单测有许多好处，例如保证函数正确运行，提高代码质量等，但单测投入资源太大，而且就算程序通过了所有单测，也不能保证程序的功能完全正常，考虑缺少测试人员的情况下，推荐选择端到端的测试，可模拟应用运行的真实环境，对完整的功能以及业务流程进行测试，保证功能的可用性，当然，若有之后还有余力也可同时进行单元集成测试，在保证功能的前提下，优化代码质量。

### 分析方案需求

- 支持端到端测试
- 支持集成测试
- 本地测试和线上测试切换方便
- 提供封装的浏览器操作接口
- 测试用例可以快速迁移到其他框架下执行
- 支持跨端测试


### 了解测试工具

1. 提供一个测试结构(Mocha, Jasmine, Jest, Cucumber)
2. 提供断言函数(Chai, Jasmine, Jest, Unexpected)
3. 生成、展示 并观察测试结果 (Mocha, Jasmine, Jest, Karma)
4. 生成并对比组件和数据结构的快照 (snapshots)确保早先运行中的变化符合预期 (Jest, Ava)
5. 提供 mocks、spies 和 stubs (Sinon, Jasmine, enzyme, Jest, testdouble)
6. 生成代码覆盖报告 (Istanbul, Jest, Blanket)
7. 提供浏览器或近似浏览器环境并可以在场景执行时进行控制 (Protractor,Nightwatch, PhantomJs,Casper,Puppeteer,Nightmare)


### 选择工具

#### Karma

Karma本质上是一个工具，它生成一个web服务器，该服务器针对连接的每个浏览器的测试代码执行源代码，为前端自动化测试提供了跨浏览器测试的能力,它也可以捕获浏览器，模拟浏览器事件。

#### Mocha

Mocha最常用的测试框架，它只提供简单的测试结构，如兼容不同风格断言库，测试用例分组，同步异步测试架构，生命周期钩子等，但主要的优点是灵活，可扩展性强，在以后需要进行功能之外的测试时，直接添加第三方库即可，无需更换测试框架，也无需重新编写测试用例。


#### Chai   

是一个断言库合集，支持Expect（BDD），Should（BDD），Assert（TDD）三种断言语法。

#### Nightmare

基于PhantomJs的高级浏览器自动化库，搭建Karma+Mocha+Chai+Webpack+Nightmare环境时，Nightmare表现不是很好，各种打包报错，一直没找到解决办法，导致没法配置Karma，仅仅使用Mocha的话，可以搭配Nightmare，但是失去了Karma运行配置简单的优势，使得Mocha各种功能插件集成繁琐，而且每用一次都需要手动引入。

#### Puppeteer

是一个Node库，它提供了一个高级API来通过DevTools协议控制无头Chrome或Chromium ，它也支持使用完整（非无头）Chrome或Chromium。

搭建Karma+Mocha+Chai+Webpack+Puppeteer环境时，Puppeteer同样不能二次打包，当然这都还是小问题，最大的问题是没法将Puppeteer的测试用例，在Karma的生成的运行环境中跑起来，查了很多资料，最终的原因在于浏览器环境与NodeJs环境不一致，Puppeteer才不能在不支持NodeJs的浏览器环境运行，我尝试Webpack集成Node环境，但最后还是没有结果，显然Karma+Webpack 不是一个好的选择，因为它没办法二次打包一些基于其他环境的第三方库。

#### Daydream

是一个简单的浏览器扩展插件，当你浏览网页时可以根据你的动作，当生成 Nightmare 或 Puppeteer 测试脚本。

#### Jest

Jest 是 Facebook 的一套开源的 JavaScript 测试框架，它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。

Jest相当于是一个手动配置好了的Mocha环境，如果你没有时间自己去研究Mocha以及相关插件的话，Jest应该是你最好的选择，不管是在单元测试或是集成测试中，它的表现都非常优异。当然，如果你时间充裕的话，你可以去尝试了解一下Mocha以及它的插件王国，相对于新兴的Jest来说老牌Mocha会更成熟，文档和社区也很丰富。但当你足够了解Mocha之后，默然回首，你会发现Jest真香。不管是单元测试，或是结合Puppeteer的端到端测试，Jest都能很好的到达预期。当然，如果你喜欢DIY，或相信自己能做得比Facebook的程序员更好的话，你可以尝试自己搭建一下Mocha测试环境。


### 搭建测试项目


1. 新建文件夹auto-test，
		
		npm init

2. 安装选定的测试工具
		
		npm install jest --save-dev
		
		npm install puppeteer --save-dev
		
		npm install babel-jest @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties --save-dev
		
		npm install -S @babel/runtime 
		
		npm install cross-env -D

3. 环境配置

> 建立如图的文件目录

![](https://i.imgur.com/lKNREOV.png)
  
> 编辑 jest.config.js，配置jest

```javascript
module.exports = {
  verbose: true,//控制台打印测试用例执行信息
  globalSetup: "./utils/setup.js",//全局启动后会执行这个文件代码，然后才运行测试用例
  globalTeardown: "./utils/teardown.js",//全部用例执行结束后,会执行这个文件代码
  testEnvironment: "./utils/puppeteerEnv.js",//测试环境
  moduleFileExtensions:["js"],//模块文件后缀
  roots: ["tests"],//测试根目录
  coverageDirectory:"coverage",//测试覆盖率or测试报告目录
  collectCoverage:true,//是否收集测试覆盖率
  reporters: [
    "default",
    ["jest-html-reporters", {
      "publicPath": "coverage/html-report",
      "filename": "report.html",
      "expand": true
    }],
  ],//测试报告
};
```

> 编辑 .babelrc，配置babel，转译es6

```json
{
  "presets": [
    "@babel/preset-env"
  ],
  "plugins": [
    "@babel/plugin-transform-runtime",
    "@babel/plugin-proposal-class-properties"
  ]
}
```

> 编辑 utils/test.config.js，提供全局配置

```javascript
let is_test = process.env.NODE_ENV === 'test' ? true : false;
const config = {
  is_test: is_test,
  domain_name: is_test ? 'https://www.baidu.com' : 'https://www.baidu.com',// 测试环境 or 生产环境
  temp_dir: 'jest_puppeteer_global_setup'
};

module.exports = config;

```



> 编辑 utils/puppeteerApi.js，二次封装基本的puppeteer函数

```javascript
import puppeteer from 'puppeteer';
import fs from 'fs';
import os from 'os';
import path from 'path';
import mkdirp from 'mkdirp';
import config from './test.config.js';

const DIR = path.join(os.tmpdir(), config.temp_dir);//创建缓存路径

//打开浏览器
const openBrowser = async () => {
  const args = [
    '--allow-running-insecure-content',  //允许不安全的脚本
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--auto-open-devtools-for-tabs',//自动打开开发者工具
    '--disable-dev-shm-usage'
  ];
  // args.push('--proxy-server='+config.domain_name);//代理
  const browser = await puppeteer.launch({
    headless: !config.is_test,
    args
  });

  const pages = await browser.pages();
  let page = pages && pages.length ? pages[0] : await browser.newPage();
  await page.goto(config.domain_name);
  await page.setViewport({
    width: 1920,
    height: 1080
  });
  const token = 'token';//设置token
  if (token) {
    await page.evaluate((token) => {
      window.localStorage.setItem('token', token);
    }, token);
  }

  mkdirp.sync(DIR);//根据缓存路径创建换成空间
  fs.writeFileSync(path.join(DIR, 'wsEndpoint'), browser.wsEndpoint());//保存wsEndpoint
};

//获取浏览器
const getBrowser = async () => {
  const wsEndpoint = fs.readFileSync(path.join(DIR, 'wsEndpoint'), 'utf8');
  if (!wsEndpoint) {
    throw new Error('wsEndpoint not found')
  }
  return await puppeteer.connect({
    browserWSEndpoint: wsEndpoint,
  });
};

//关闭浏览器
const closeBrowser = async () => {
  let browser = await getBrowser();
  browser.close();
};

//打开新页面
const openNewPage = async () => {
  let browser = await getBrowser();
  return await browser.newPage();
};

export {openBrowser,getBrowser, closeBrowser, openNewPage}
```

>编辑 utils/setup.js，全局启动后会执行这个文件代码，然后才运行测试用例

```javascript
import {openBrowser} from "./puppeteerApi.js";

module.exports = async () => {
  await openBrowser();//打开浏览器
};
```

>编辑 utils/teardown.js，//全部用例执行结束后,会执行这个文件代码

```javascript
import {closeBrowser} from "./puppeteerApi";

module.exports = async () => {
  await closeBrowser();//关闭浏览器
};
```

>编辑 utils/puppeteerEnv.js，配置puppeteer测试环境

```javascript
const NodeEnvironment = require('jest-environment-node');
const puppeteer = require('puppeteer');
const fs = require('fs');
const os = require('os');
const path = require('path');
const globalConfig = require('./test.config.js');

const DIR = path.join(os.tmpdir(), globalConfig.temp_dir);

class PuppeteerEnvironment extends NodeEnvironment {

  constructor(config) {
    super(config)
  }

  async setup() {
    await super.setup();
    const wsEndpoint = fs.readFileSync(path.join(DIR, 'wsEndpoint'), 'utf8');
    if (!wsEndpoint) {
      throw new Error('wsEndpoint not found')
    }
    const browser = await puppeteer.connect({
      browserWSEndpoint: wsEndpoint,
    });

    const page_list = await browser.pages();
    for (let i = 0, size = page_list.length; i < size; i++) {
      const page = page_list[i];
      //判断域名，如果不判断页面域名直接调用window.localStorage，会报错的
      if (page.url().indexOf(globalConfig.domain_name) >= 0) {
        this.global.__TOKEN__ = await page.evaluate(() => {
          return window.localStorage.getItem('token')
        });
        break
      }
    }
    browser.openNewPage = async (mockRequest) => {
      const page = await browser.newPage();
      await page.setRequestInterception(true);
      page.on('request', interceptedRequest => {
        const url = interceptedRequest.url();
        if (mockRequest) {
          mockRequest(interceptedRequest);
        } else {
          interceptedRequest.continue();
        }
      });
      this.global.page = page;
      page.on('close', () => {
        this.global.pageClosed = true
      });
      return page;
    };
    this.global.__BROWSER__ = browser;
  }

  async teardown() {
    if (this.global.page && !this.global.pageClosed) {
      console.log('this.page=', this.global.page.url())
      await this.global.page.close()
    }
    if (this.global.__BROWSER__) {
      await this.global.__BROWSER__.disconnect()
    }
    await super.teardown()
  }

  runScript(script) {
    return super.runScript(script)
  }
}

module.exports = PuppeteerEnvironment;
```

>编辑package.json，添加运行命令，通过cross-env指定运行环境

```json
{
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "jest": "cross-env NODE_ENV=test jest --config ./jest.config.js",
    "jest:product": " cross-env NODE_ENV=production jest --config ./jest.config.js"
  }
}
```

>添加端到端测试的测试用例utils/app_1/demo.test.js，用例按照jest规范，以*.test.js结尾，jest会自动匹配执行的用例。

```javascript
import {getBrowser,openNewPage} from "../../utils/puppeteerApi";

describe('ly.com demo cases', () => {
  let page = null;
  beforeEach(async () => {
    page = await openNewPage();
    await page.goto('https://www.ly.com/');
  });
  afterEach(async ()=> {
    await page.close();
  });
  test('test-ly-demo', async () => {
    const logo = await page.$eval('.logo', el => el.getAttribute('title'));
    await expect(logo).toEqual('旅游');
  });
});

describe('baidu demo cases', () => {
  let page = null;
  beforeEach(async () => {
    page = await openNewPage();
    await page.goto('https://baidu.com/');
  });
  afterEach(async ()=> {
    await page.close();
  });
  test('test-ly-demo', async () => {
    await page.type('#kw', '测试',{delay: 100});
    page.click('#su');
    await page.waitFor(1000);
  });
});
```
>添加单元测试的测试用例utils/app_1/sum.test.js，命名规范同上

```javascript
function sum(a, b) {
  return a + b;
}

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

>就此环境和用例全部完成，本地运行或上线运行

    npm run jest  
    
    npm run jest:production

# 事件循环机制—Event Loop

## 简介

Event Loop 是一个代码执行模型。

## Event Loop 的来源

1. JavaScript 是单线程的，也就是说，同一时间只能做一件事，JavaScript 单线程的设计 ，与它的用途有关，针对浏览器脚本而言，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？因此为了避免多线程引起的一系列复杂的数据同步的问题，JavaScript 设计之初就是单线程的，尽管 HTML5 提出了 web worker 的标准，允许 JavaScript 创建多个脚本，但其子线程完全受主线程控制，且不得操作 DOM，因此这并没有改变 JavaScript 单线程的本质。

2. 单线程就意味着，代码解释执行时，需要创建任务队列，也就是说只有等前一个任务结束，才会执行后面的任务，若是前一个任务的耗时很长，后面的任务只能继续排队等待。在 JavaScript 中，所有的任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

3. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack），当“执行栈”中的所有同步任务执行完毕，就会自动读取“任务队列”中事件。

4. “任务队列”是一个事件的队列（也可以理解成消息的队列），当异步任务有了运行结果，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入“执行栈”了。主线程读取“任务队列”，就是读取里面有哪些事件。

5. “任务队列”中的事件，除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入“任务队列”，等待主线程读取。

6. 所谓“回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

7. “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，“任务队列”上第一位的事件就自动进入主线程。

8. 主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

## 宏任务和微任务

异步任务分为宏任务和微任务，宏任务会进入一个队列，而微任务会进入到另一个不同的队列，且微任务要优于宏任务执行。

### 宏任务

- setTimeout
- setInterval
- setImmediate (Node 独有)
- requestAnimationFrame (浏览器独有)
- I/O
- UI rendering (浏览器独有)

### 微任务
- process.nextTick (Node独有)
- Promise
- Object.observe
- MutationObserver

> 每次单个宏任务执行完毕后，检查微任务队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务后，设置微任务队列为null，然后再执行宏任务，如此循环。可将执行栈看成是一个宏任务。